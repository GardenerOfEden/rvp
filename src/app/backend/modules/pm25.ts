/**
 * Piecemaker 2.5
 * @module pm25
 */
import * as _ from 'lodash';
import * as PouchDB from 'pouchdb';
import * as newAjv from 'ajv'; // another json validator

declare var emit;

export default function createPM(options?) {
  // console.dir(newAjv);

  var db;

  var ajv = newAjv();

  // set option defaults
  options = _.defaults(options, {
    'name': 'pm25',
    'validateObjects': true
  });

  /**
   * [init description]
   * @return {Promise} [description]
   */
  function init() {
    db = new PouchDB(options.name); // create or open db

    var ddocs = [{
      _id: '_design/events',
      views: {
        by_group: {
          map: function (doc) {
            if (doc.type == 'group') {
              emit( [doc._id], 0 );
            } else if (doc.type == 'event') {
              emit( [doc.group], 1 );
            }
          }.toString()
        },
        all: {
          map: function (doc) {
            if (doc.type == 'event') {
              emit( doc._id );
            }
          }.toString()
        }
      }
    }, {
      _id: '_design/groups',
      views: {
        all: {
          map: function (doc) {
            if (doc.type == 'group') {
              emit( doc._id );
            }
          }.toString()
        }
      }
    }];

    return db.bulkDocs(ddocs).catch((err) => {
      // TODO: expect this error
      // some error (maybe a 409, because it already exists?)
      console.log(err);
    }).then(() => {
      // build indices by querying
      return Promise.all([
        db.query( 'events/by_group', {limit:0} ),
        db.query( 'events/all', {limit:0} ),
        db.query( 'groups/all', {limit:0} )
      ]);
    }).then(() => {
      return {ok:true};
    });
  }

  /**
   * [groupSchema description]
   * @type {Object}
   */
  var groupSchema = {
    "$schema": "http://json-schema.org/schema#",
    "title": "Group",
    "description": "Piecemaker 2.5 Group Object",
    "type": "object",
    "properties": {
      "_id": {
        "type": "string"
      },
      "_rev": {
        "type": "string"
      },
      "type": {
        "enum": ["group"]
      },
      "parent": {
        "type": ["string", "null"]
      },
      "fields": {
        "type": "object"
      }
    },
    "additionalProperties": false,
    "required": ["type"]
  };

  /**
   * [eventSchema description]
   * @type {Object}
   */
  var eventSchema = {
    "$schema": "http://json-schema.org/schema#",
    "title": "event",
    "description": "Piecemaker 2.5 Event Object",
    "type": "object",
    "properties": {
      "_id": {
        "type": "string"
      },
      "_rev": {
        "type": "string"
      },
      "type": {
        "enum": ["event"]
      },
      "group": {
        "type": "string"
      },
      "utc_timestamp": {
        "type": "number"
      },
      "event_type": {
        "type": "string"
      },
      "fields": {
        "type": "string"
      }
    },
    "additionalProperties": false,
    "required": ["type", "group", "utc_timestamp"]
  };

  var idSchema = {
    "$schema": "http://json-schema.org/schema#",
    "title": "id",
    "description": "",
    "type": "object",
    "properties": {
      "_id": {
        "type": "string"
      }
    },
    "additionalProperties": true,
    "required": ["_id"]
  };

  var idRevSchema = {
    "$schema": "http://json-schema.org/schema#",
    "title": "idRev",
    "description": "",
    "type": "object",
    "properties": {
      "_id": {
        "type": "string"
      },
      "_rev": {
        "type": "string"
      }
    },
    "additionalProperties": true,
    "required": ["_id", "_rev"]
  };

  var validateGroup = ajv.compile(groupSchema);
  var validateEvent = ajv.compile(eventSchema);
  var validateId = ajv.compile(idSchema);
  var validateIdRev = ajv.compile(idRevSchema);

  /**
   * createGroup()
   * createEvent()
   *
   * deleteGroup()
   * deleteEvent()
   *
   * allGroups()
   * allEvents()
   *
   * groupWithEvents()
   *
   */

  function createGroup(group) {
    // type property is fixed
    group.type = 'group';
    group._id = undefined;
    group._rev = undefined;
    // validate input
    if (options.validateObjects) {
      if (!validateGroup(group)) {
        return Promise.reject(validateGroup.errors[0]);
      }
    }
    // create doc with autogenerated _id
    return db.post(group).then(result => {
      // add group object to result (with _id and _rev)
      result.group = group;
      result.group._id = result.id;
      result.group._rev = result.rev;
      return result;
    });
  }

  function updateGroup(group) {
    // validate input
    if (options.validateObjects) {
      if (!validateIdRev(group)) {
        return Promise.reject(validateIdRev.errors[0]);
      }
      if (!validateGroup(group)) {
        return Promise.reject(validateGroup.errors[0]);
      }
    }
    // update doc (with given _id and _rev)
    return db.put(group).then(result => {
      // add group object to result (with _id and _rev)
      result.group = group;
      result.group._id = result.id;
      result.group._rev = result.rev;
      return result;
    });
  }

  function deleteGroup(group) {
    // validate input
    if (options.validateObjects) {
      if (!validateIdRev(group)) {
        return Promise.reject(validateIdRev.errors[0]);
      }
      if (!validateGroup(group)) {
        return Promise.reject(validateGroup.errors[0]);
      }
    }
    // remove doc (with given _id and _rev)
    return db.remove(group);
  }

  function allGroups() {
    return db.query('groups/all', {include_docs:true});
  }


  function createEvent(event) {
    // type property is fixed
    event.type = 'event';
    event._id = undefined;
    event._rev = undefined;
    // validate input
    if (options.validateObjects) {
      if (!validateEvent(event)) {
        return Promise.reject(validateEvent.errors[0]);
      }
    }
    // create doc with autogenerated _id
    return db.post(event).then(result => {
      // add group object to result (with _id and _rev)
      result.event = event;
      result.event._id = result.id;
      result.event._rev = result.rev;
      return result;
    });
  }

  function updateEvent(event) {
    // validate input
    if (options.validateObjects) {
      if (!validateIdRev(event)) {
        return Promise.reject(validateIdRev.errors[0]);
      }
      if (!validateEvent(event)) {
        return Promise.reject(validateEvent.errors[0]);
      }
    }
    // update doc (with given _id and _rev)
    return db.put(event).then(result => {
      // add group object to result (with _id and _rev)
      result.event = event;
      result.event._id = result.id;
      result.event._rev = result.rev;
      return result;
    });
  }

  function deleteEvent(event) {
    // validate input
    if (options.validateObjects) {
      if (!validateIdRev(event)) {
        return Promise.reject(validateIdRev.errors[0]);
      }
      if (!validateGroup(event)) {
        return Promise.reject(validateEvent.errors[0]);
      }
    }
    // remove doc (with given _id and _rev)
    return db.remove(event);
  }

  function allEvents() {
    return db.query('events/all', {include_docs:true});
  }

  function eventsInGroup(group) {
    return db.query('events/by_group', {
      include_docs:true,
      startkey: [group._id, 0],
      endkey: [group._id, 1, {}],
    });
  }

  /**
   * reset database
   * @return {Promise} resolves to an object with an 'ok' property of true
   */
  function reset() {
    return db.destroy().then(() => {
      return init();
    });
  }

  // db API
  return {
    init,
    reset,
    group: {
      create: createGroup,
      update: updateGroup,
      delete: deleteGroup
    },
    groups: {
      all: allGroups
    },
    event: {
      create: createEvent,
      update: updateEvent,
      delete: deleteEvent
    },
    events: {
      all: allEvents,
      in_group: eventsInGroup
    }
  };
};
